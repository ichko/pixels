-- phpMyAdmin SQL Dump
-- version 4.7.4
-- https://www.phpmyadmin.net/
--
-- Host: 127.0.0.1
-- Generation Time: Jan 23, 2018 at 11:29 PM
-- Server version: 10.1.29-MariaDB
-- PHP Version: 7.2.0

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `test`
--

-- --------------------------------------------------------

--
-- Table structure for table `snippets`
--

-- CREATE TABLE `snippets` (
--   `id` int(11) NOT NULL,
--   `name` varchar(256) NOT NULL,
--   `description` varchar(512) NOT NULL,
--   `code` text NOT NULL,
--   `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
--   `user_id` int(11) NOT NULL
-- ) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `snippets`
--

INSERT INTO `snippets` (`id`, `name`, `description`, `code`, `date_created`, `user_id`) VALUES
(1, 'Polar heart', '', 'let range = n => Array.from(Array(n).keys())\n\nclass Vector {\n\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n\n    reflect() {\n        return new Vector(-this.x, -this.y);\n    }\n\n    add(vector) {\n        return new Vector(this.x + vector.x, this.y + vector.y);\n    }\n\n    subtract(vector) {\n        return new Vector(this.x - vector.x, this.y - vector.y);\n    }\n\n    scale(scalar = 1) {\n        return new Vector(this.x * scalar, this.y * scalar);\n    }\n\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    distance(vector) {\n        let dx = this.x - vector.x;\n        let dy = this.y - vector.y;\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n}\n\nclass IO {\n\n    constructor() {\n        this.mouse = new Vector();\n        this.bindMouse();\n    }\n\n    bindMouse() {\n        window.addEventListener(\'mousemove\', ({ x , y }) => {\n            this.mouse.x = x;\n            this.mouse.y = y;\n        });\n    }\n\n}\n\nclass Point {\n\n    constructor({ position = new Vector(), color = \'#f00\', size = 3 }) {\n        this.position = position;\n        this.color = color;\n        this.size = size;\n    }\n\n    render(ctx) {\n        ctx.beginPath();\n\n        ctx.fillStyle = this.color;\n        ctx.arc(this.position.x, this.position.y, this.size, 0, 2 * Math.PI);\n        ctx.fill();\n\n        ctx.closePath();\n    }\n\n}\n\nclass SpringPoint extends Point {\n\n    constructor({ target = new Vector(), elasticity = 1e-1, color = \'rgba(255, 0, 0, .6)\', size = 3, damping = 1e-1 }) {\n        super({ position: target, color, size });\n        this.velocity = new Vector();\n        this.target = target;\n        this.elasticity = elasticity;\n        this.damping = damping;\n    }\n\n    updateVelocity() {\n        let damping = this.velocity.scale(this.damping);\n        let force = this.target\n            .subtract(this.position)\n            .scale(this.elasticity)\n            .subtract(damping);\n\n        this.velocity = this.velocity.add(force);\n    }\n\n    updatePosition() {\n        this.position = this.position.add(this.velocity);\n    }\n\n    update() {\n        this.updatePosition();\n        this.updateVelocity();\n    }\n\n}\n\nclass SpringTrail extends SpringPoint {\n\n    constructor(config) {\n        super(config);\n        this.trail = range(config.trailSize || 10).map(index => {\n            config.target = this.position;\n            config.elasticity = 1 / (index * 8);\n            config.damping = 8 / (index * 10 + 5);\n            return new SpringPoint(config);\n        });\n    }\n\n    update() {\n        super.update();\n        this.trail.forEach(point => point.update());\n    }\n\n    render(ctx) {\n        super.render(ctx);\n        this.trail.forEach(point => point.render(ctx));\n    }\n\n}\n\n\nclass Physics {\n\n    update(objects) {\n        objects.forEach(object => object.update());\n    }\n\n}\n\nclass Renderer {\n\n    constructor(ctx, size = { width: 100, height: 100 }) {\n        this.ctx = ctx;\n        this.size = size;\n    }\n\n    render(objects) {\n        objects.forEach(object => object.render(ctx));\n    }\n\n    clear() {\n        this.ctx.fillStyle = \'rgba(0, 0, 0, .2)\';\n        this.ctx.fillRect(0, 0, this.size.width, this.size.height);\n    }\n\n}\n\nclass Engine {\n\n    constructor(physics, renderer, objects = []) {\n        this.physics = physics;\n        this.renderer = renderer;\n        this.objects = objects;\n    }\n\n    add(...objects) {\n        this.objects = this.objects.concat(objects);\n    }\n\n    tick() {\n        this.physics.update(this.objects);\n    }\n\n    render() {\n        this.renderer.render(this.objects);\n    }\n\n    clear() {\n        this.renderer.clear();\n    }\n\n}\n\n\n  let canvas = document.getElementById(\'canvas\');\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            let ctx = canvas.getContext(\'2d\');\n\n            let io = new IO();\n            let engine = new Engine(\n                new Physics(),\n                new Renderer(ctx, { width: canvas.width, height: canvas.height })\n            );\n\n            let origin = new Vector(canvas.width / 2, canvas.height / 2);\n\n            // This  is what generates the shape\n            let polar = (rad, time) => {\n                rad += Math.sin(time / 100);\n                let x = 16 * Math.sin(rad) ** 3;\n                let y = 13 * Math.cos(rad) - 5 * Math.cos(2 * rad) - 2 * Math.cos(3 * rad) - Math.cos(4 * rad);\n                let scale = (Math.sin(time / 10) + 3) * 4;\n                return new Vector(x * scale, -y * scale)\n                    .add(origin.add(io.mouse.subtract(origin).scale(0.5)));\n            };\n\n            let random = (min = 0, max = 1) => Math.random() * (max - min) + min;\n\n            let targetsSize = 60;\n\n            // Creating the points for the shape\n            let targets = [];\n            for (let i = 0;i < targetsSize; i++) {\n                let target = new Vector(random(0, canvas.width), random(0, canvas.height));\n                engine.add(new SpringTrail({ target: target, size: 1.3, trailSize: 10, color: \"rgba(230, 10, 40, 0.8)\" }));\n                targets.push(target);\n            }\n\n            let time = 0;\n            (function animate(){\n                time++;\n                engine.clear();\n                engine.tick();\n                engine.render();\n\n                updateTargets();\n\n                window.requestAnimationFrame(animate);\n            })();\n\n            // Applying the shape to the target points\n            function updateTargets() {\n                for (let i = 0;i < targetsSize; i++) {\n                    let lerp = i / (targetsSize - 1) * Math.PI * 2 + random() / 10;\n                    let result = polar(lerp, time);\n                    targets[i].x = result.x;\n                    targets[i].y = result.y;\n                    \n                    // Randomly swap two points\n                    if (random() < 0.004) {\n                        let rnd1 = Math.floor(random(0, targets.length));\n                        let rnd2 = Math.floor(random(0, targets.length));\n                        [targets[rnd1], targets[rnd2]] = [targets[rnd2], targets[rnd1]];\n                    }\n                }\n            }\n', '2018-01-23 22:00:58', 1),
(2, 'Parallax', '', 'var width = window.innerWidth;\r\nvar height = window.innerHeight;\r\n\r\nvar canvas = document.getElementById(\"canvas\");\r\nvar ctx = canvas.getContext(\'2d\');\r\ncanvas.width = width;\r\ncanvas.height = height;\r\nctx.translate (canvas.width/2, canvas.height/2);\r\n\r\nvar colors = [\'114, 203, 219\', \'85, 19, 78\', \'160, 89, 107\', \'254, 195, 67\', \'239, 115, 81\', \'142, 220, 157\'];\r\n\r\nvar layers = [];\r\nvar points = [];\r\n\r\nvar toggleMouse = false;\r\n\r\nfor(var i = 1;i <= 10;i++){\r\n	var objs = [];\r\n	for(var j = 0;j < 20;j++){\r\n		var x = rand(-width, width);\r\n		var y = rand(-height, height)\r\n		var color = colors[rand(0, colors.length)];\r\n		\r\n		objs.push(new obj(new circle(new point(x, y), i * 3, \r\n		\'rgba(\' + color +\', \'+ (i)/2 +\')\'), drawCircle));\r\n		points.push(new point(x, y));\r\n	}\r\n	layers.push(new layer(i/5, objs));\r\n}\r\n\r\nvar mouse = new point(0, 0);\r\nvar myParallax = new parallax(new point(1, 1), layers);\r\nvar param = 0;\r\n\r\nvar param = 0;\r\nfunction animate(){\r\n	clear();\r\n	\r\n	var fx = Math.sin(param * 4) * 200 + 150;\r\n  if(toggleMouse){\r\n    myParallax.regPoint.x = mouse.x / 2;\r\n    myParallax.regPoint.y = mouse.y / 4;\r\n  }else{\r\n    myParallax.regPoint.x = Math.cos(param) * fx;\r\n    myParallax.regPoint.y = Math.sin(param) * fx;\r\n		param += 0.01;\r\n  }\r\n  \r\n	\r\n	drawParallax(myParallax);\r\n	requestAnimationFrame(animate);\r\n}\r\nanimate();\r\n\r\nfunction drawParallax(myParallax){\r\n	for(var i = 0;i < myParallax.layers.length;i++){\r\n		var layerZindex = myParallax.layers[i].zindex;\r\n		var thisObjs = myParallax.layers[i].objs;\r\n		var copyObjs = [];\r\n		\r\n		for(var j = 0;j < thisObjs.length;j++){\r\n			var objCopy = copy(thisObjs[j]);\r\n			objCopy.struct.pos = translate(objCopy.struct.pos, myParallax.regPoint);\r\n			objCopy.struct.pos = mult(objCopy.struct.pos, layerZindex);\r\n			\r\n			thisObjs[j].drawFunc(objCopy.struct);\r\n		}\r\n	}\r\n}\r\n\r\n\r\n\r\n/////////////\r\n\r\nfunction translate(pointA, pointB){\r\n	return new point(pointA.x + pointB.x, pointA.y + pointB.y+10);\r\n}\r\n\r\nfunction mult(pointA, n){\r\n	return new point(pointA.x * n, pointA.y * n);\r\n}\r\n\r\nfunction parallax(regPoint, layers){\r\n	this.regPoint = regPoint;\r\n	this.layers = layers;\r\n}\r\n\r\nfunction layer(zindex, objs){\r\n	this.zindex = zindex;\r\n	this.objs = objs;\r\n}\r\n\r\nfunction point(x, y){\r\n	this.x = x;\r\n	this.y = y;\r\n}\r\n\r\nfunction copy(src){\r\n	// Deep copy hack\r\n	var str = JSON.stringify(src);\r\n	eval(\"var dst = \" + str);\r\n	return dst;\r\n}\r\n\r\nfunction rect(pos, width, height, color){\r\n	this.pos = pos;\r\n	this.width = width;\r\n	this.height = height;\r\n	this.color = color;\r\n}\r\n\r\nfunction circle(pos, rad, color){\r\n	this.pos = pos;\r\n	this.rad = rad;\r\n	this.color = color;\r\n}\r\n\r\nfunction obj(struct, drawFunc){\r\n	this.struct = struct;\r\n	this.drawFunc = drawFunc;\r\n}\r\n\r\nfunction complexObj(refPoint, objs){\r\n	this.refPoint = refPoint;\r\n	this.objs = objs;\r\n}\r\n\r\nfunction clear(){\r\n	ctx.fillStyle = \"rgba(255, 255, 255, 0.6)\";\r\n	//ctx.clearRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);\r\n	ctx.fillRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);\r\n}\r\n\r\nfunction iterate(objs, func){\r\n	for(var i = 0;i < objs.length;i++){\r\n		func(objs[i]);\r\n	}\r\n}\r\n\r\nfunction dir(pointA, pointB){\r\n	return -Math.atan2(pointB.x - pointA.x, pointB.y - pointA.y) + Math.PI/2;\r\n}\r\n\r\nfunction dist(pointA, pointB){\r\n	return Math.sqrt((pointA.x - pointB.x) * (pointA.x - pointB.x) + (pointA.y - pointB.y) * (pointA.y - pointB.y));\r\n}\r\n\r\nfunction rand(min, max){\r\n	var dist = max - min;\r\n	return Math.floor(Math.random() * dist) + min;\r\n}\r\n\r\nfunction drawCircle(circle){\r\n	ctx.beginPath();\r\n	ctx.fillStyle = circle.color || \"#ff0000\";\r\n	ctx.arc(circle.pos.x, circle.pos.y, circle.rad, 0, 2 * Math.PI, false);\r\n	ctx.fill();\r\n	ctx.closePath();\r\n}\r\n\r\nfunction drawRect(rect){\r\n	ctx.fillStyle = rect.color || \"#ff0000\";\r\n	ctx.fillRect(rect.pos.x, rect.pos.y, rect.width, -rect.height);\r\n}\r\n\r\nfunction drawLine(pointA, pointB, size, color){\r\n	ctx.strokeStyle = color;\r\n	ctx.lineWidth = size;\r\n	ctx.beginPath();\r\n	ctx.moveTo(pointA.x, pointA.y);\r\n	ctx.lineTo(pointB.x, pointB.y);\r\n	ctx.stroke();\r\n	ctx.closePath();\r\n}\r\n\r\ncanvas.addEventListener(\'mousemove\', function(e){\r\n	mouse.x = e.clientX - canvas.width/2;\r\n	mouse.y = e.clientY - canvas.height/2;\r\n});\r\n\r\ncanvas.addEventListener(\'mouseover\', function(e){\r\n	toggleMouse = true;\r\n});\r\n\r\ncanvas.addEventListener(\'mouseout\', function(e){\r\n	toggleMouse = false;\r\n});\r\n\r\n\r\n// Curve\r\n\r\nfunction mkCurve(curveForm){\r\n	var localTimeStep = 5;\r\n	var curveRes = [];\r\n	\r\n	for(var localTime = 0;localTime <= 100;localTime += localTimeStep){\r\n		var myPointArr = curveForm;\r\n		while(myPointArr.length > 1){\r\n			var updateArr = [];\r\n			for(var i = 1;i < myPointArr.length;i++){\r\n				updateArr.push(getCurvePoint(myPointArr[i - 1], myPointArr[i], localTime));\r\n				\r\n				var color = \"#00ffff\";\r\n				if(Math.abs(iAnim - i) < 5){\r\n					color = \"#FF0080\";\r\n				}\r\n				if(curveRes.length == 2){\r\n					drawLine(myPointArr[i - 1], myPointArr[i], 0.3, color);\r\n				}\r\n			}\r\n			myPointArr = updateArr;\r\n		}\r\n		curveRes.push(myPointArr[0]);\r\n	}\r\n	iAnim = (iAnim + 1) % 50;\r\n	\r\n	return curveRes;\r\n}\r\n\r\nfunction drawLines(curveData, color, size){\r\n	for(var i = 1;i < curveData.length;i++){\r\n		drawLine(curveData[i - 1], curveData[i], size, color);\r\n	}\r\n}\r\n\r\n', '2018-01-23 22:06:05', 1),
(3, 'Pythagoras tree (fractal)', '', 'var width = window.innerWidth;\r\nvar height = window.innerHeight;\r\n\r\nvar canvas = document.getElementById(\"canvas\");\r\nvar ctx = canvas.getContext(\'2d\');\r\ncanvas.width = width;\r\ncanvas.height = height;\r\nctx.translate (canvas.width/2, canvas.height/2);\r\n\r\nctx.fillStyle = \"#000000\";\r\n\r\nvar angle = Math.PI / 2;\r\nvar iterations = 1;\r\n\r\nvar colors = [\"72CBDB\", \"55134E\", \"A0596B\", \"FEC343\", \"EF7351\", ];\r\nvar colorId = 0;\r\n\r\nvar andleOfExpL = Math.PI / 6;\r\nvar andleOfExpR = Math.PI / 3;\r\n\r\nfunction iterate(startPoitn, deg, iteration){\r\n	var lenght = (iterations / iteration) * 15;\r\n	var lineBeginning = startPoitn;\r\n	var size = lenght/30;\r\n	\r\n	var lineEnding = new point(lineBeginning.x + lenght * Math.cos(deg + andleOfExpL), lineBeginning.y + lenght * Math.sin(deg + andleOfExpL));\r\n	var lineEnding2 = new point(lineBeginning.x + lenght * Math.cos(deg - andleOfExpR), lineBeginning.y + lenght * Math.sin(deg - andleOfExpR));\r\n	\r\n	drawLine(lineBeginning, lineEnding, size);\r\n	drawLine(lineBeginning, lineEnding2, size);\r\n	\r\n	if(iteration > iterations){\r\n		ctx.fillStyle = \"#\" + colors[colorId % colors.length];\r\n		colorId++;\r\n		ctx.arc(lineEnding.x, -lineEnding.y, 5, 0, 2 * Math.PI, false);\r\n		ctx.closePath();\r\n		ctx.arc(lineEnding2.x, -lineEnding2.y, 3, 0, 2 * Math.PI, false);\r\n		ctx.fill();\r\n		return;\r\n	}\r\n	\r\n	iterate(lineEnding, deg + andleOfExpL, iteration + 1);\r\n	iterate(lineEnding2, deg - andleOfExpR, iteration + 1);\r\n}\r\n\r\n\r\nvar param = 0;\r\nfunction animate(){\r\n	if(iterations < 7){\r\n		iterations += 0.05;\r\n	}\r\n	clear();\r\n	colorId = 0;\r\n	andleOfExpR = getDir(new point(0, Math.sin(param/20)*8), new point(Math.abs(mouse.x), mouse.y));\r\n	andleOfExpL = getDir(new point(0, Math.sin(param/10)*10), new point(Math.abs(mouse.x), mouse.y));\r\n	\r\n	drawLine(new point(0,-50), new point(0, -150), 4);\r\n	iterate(new point(0,-50), angle, 1);\r\n	param++;\r\n}\r\n\r\nsetInterval(animate, 25);\r\n\r\nfunction clear(){\r\n  ctx.clearRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);\r\n}\r\n\r\nvar mouse = new point(10, 10);\r\ncanvas.addEventListener(\'mousemove\', function(e){\r\n	mouse.x = e.clientX - $(\'#canvas\').offset().left - canvas.width/2;\r\n	mouse.y = -(e.clientY - $(\'#canvas\').offset().top - canvas.height/2);\r\n});\r\n\r\nfunction getDir(pointA, pointB){\r\n	//return Math.atan(-(pointB.y - pointA.y) / (pointB.x - pointA.x));\r\n	return -Math.atan2(pointB.x - pointA.x, pointB.y - pointA.y) + Math.PI/2;\r\n}\r\n\r\nfunction rand(min, max){\r\n	return Math.floor(Math.random() * max) + min;\r\n}\r\n\r\nfunction point(x, y){\r\n	this.x = x;\r\n	this.y = y;\r\n}\r\n\r\nfunction drawLine(pointA, pointB, size){\r\n	x1 = pointA.x;\r\n	y1 = pointA.y;\r\n	x2 = pointB.x;\r\n	y2 = pointB.y;\r\n	\r\n	y2 = -y2;\r\n	y1 = -y1;\r\n\r\n	ctx.strokeStyle = \"rgba(141, 89, 36,\" + (size/iterations + 0.3) + \")\";\r\n\r\n	ctx.lineWidth = size;\r\n	ctx.beginPath();\r\n	ctx.moveTo(x1, y1);\r\n	ctx.lineTo(x2, y2);\r\n	ctx.stroke();\r\n	ctx.closePath();\r\n	//ctx.fillRect(x2 - 1, y2 - 1, 2, 2);\r\n}', '2018-01-23 22:06:23', 1),
(4, 'WASD - 2D Physics Experiment', '', 'var input = (function() {\r\n    var keyCode = {\r\n        UP: 38,\r\n        DOWN: 40,\r\n        LEFT: 37,\r\n        RIGHT: 39,\r\n        SPACE: 32,\r\n        W: 87,\r\n        S: 83,\r\n        A: 65,\r\n        D: 68,\r\n        Q: 81,\r\n        E: 69\r\n    };\r\n\r\n    var mouse = {\r\n        x: 0,\r\n        y: 0\r\n    };\r\n\r\n    var keyState = (function () {\r\n        var state = {};\r\n        Object.keys(keyCode).forEach(function (key, value) {\r\n            state[keyCode[key]] = false;\r\n        });\r\n\r\n        return state;\r\n    })();\r\n\r\n    function getAsyncKeyState(state) {\r\n        return keyState[state];\r\n    }\r\n\r\n    document.addEventListener(\'mousemove\', function (e) {\r\n        mouse.x = e.clientX;\r\n        mouse.y = e.clientY;\r\n    });\r\n\r\n    document.addEventListener(\'keydown\', function (e) {\r\n        if (keyState[e.keyCode] != undefined) {\r\n            keyState[e.keyCode] = true;\r\n        }\r\n    });\r\n\r\n    document.addEventListener(\'keyup\', function (e) {\r\n        if (keyState[e.keyCode] != undefined) {\r\n            keyState[e.keyCode] = false;\r\n        }\r\n    });\r\n\r\n    return {\r\n        getAsyncKeyState: getAsyncKeyState,\r\n        keyCode: keyCode,\r\n        mouse: mouse\r\n    };\r\n})();\r\n\r\nvar force = function(angle, magnitude){\r\n    this.angle = angle;\r\n    this.magnitude = magnitude;\r\n};\r\n\r\nvar rPoint = function(x, y, velocity, forces){\r\n    this.x = x;\r\n    this.y = y;\r\n    this.velocity = velocity;\r\n    this.forces = forces;\r\n};\r\n\r\nvar circle = {\r\n    x: 0,\r\n    y: 0,\r\n    radius: 5,\r\n    velocity: null,\r\n    forces: null,\r\n\r\n    create: function(_x, _y, _radius){\r\n        x = _x;\r\n    },\r\n\r\n    render: function(){\r\n        ctx.beginPath();\r\n        ctx.fillStyle = \"#F25E5C\";\r\n        ctx.arc(points[i].x, points[i].y, 10, 0, Math.PI * 2, false);\r\n        ctx.fill();\r\n        ctx.closePath();\r\n    }\r\n};\r\n\r\nfunction getPointNextPos(point){\r\n    var result = new rPoint(point.x, point.y, point.velocity, point.forces);\r\n    var actingForces = addForceArr(point.forces);\r\n    result.velocity = addForces(point.velocity, actingForces);\r\n\r\n    result.x += Math.cos(point.velocity.angle) * point.velocity.magnitude;\r\n    result.y -= Math.sin(point.velocity.angle) * point.velocity.magnitude;\r\n    return result;\r\n}\r\n\r\nfunction forceToPoint(myforce){\r\n    return new rPoint(Math.cos(myforce.angle) * myforce.magnitude, Math.sin(myforce.angle) * myforce.magnitude);\r\n}\r\n\r\nfunction pointToForce(mypoint){\r\n    return new force(direction(new rPoint(0,0), mypoint), distance(new rPoint(0,0), mypoint));\r\n}\r\n\r\nfunction flipY(myforce){\r\n    var point = forceToPoint(myforce);\r\n    point.x = -point.x;\r\n    return new force(direction(new rPoint(0,0), point), myforce.magnitude);\r\n}\r\n\r\nfunction flipX(myforce){\r\n    var point = forceToPoint(myforce);\r\n    point.y = -point.y;\r\n    return new force(direction(new rPoint(0,0), point), myforce.magnitude);\r\n}\r\n\r\nfunction distance(a, b){\r\n    return Math.sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y));\r\n}\r\n\r\nfunction direction(a, b){\r\n    return Math.atan2(b.y - a.y, b.x - a.x);\r\n}\r\n\r\nfunction addForces(a, b){\r\n    var aPoint = forceToPoint(a);\r\n    var bPoint = forceToPoint(b);\r\n    return new pointToForce(new rPoint(aPoint.x + bPoint.x, aPoint.y + bPoint.y));\r\n}\r\n\r\nfunction addForceArr(forces){\r\n    var result = new force(0, 0);\r\n    for(var i = 0;i < forces.length;i++){\r\n        result = addForces(result, forces[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction collision(points){\r\n    for(var i = 0;i < points.length;i++){\r\n        var newPoint = getPointNextPos(points[i]);\r\n        if(newPoint.y > canvas.height - 10){\r\n            points[i].velocity = flipX(points[i].velocity);\r\n        }\r\n        if(newPoint.y < 10){\r\n            points[i].velocity = flipX(points[i].velocity);\r\n        }\r\n        if(newPoint.x < 10){\r\n            points[i].velocity = flipY(points[i].velocity);\r\n        }\r\n        if(newPoint.x > canvas.width - 10){\r\n            points[i].velocity = flipY(points[i].velocity);\r\n        }\r\n\r\n        if(newPoint.y > canvas.height - 10 || newPoint.y < 10 || newPoint.x < 10 || newPoint.x > canvas.width - 10){\r\n            points[i].velocity.magnitude = points[i].velocity.magnitude / 2;\r\n            if(points[i].velocity.magnitude < 1.1){\r\n                points[i].velocity.magnitude = 0;\r\n            }\r\n        }\r\n\r\n        //points[i].velocity.magnitude /= 1.5;\r\n    }\r\n}\r\n\r\nvar canvas = document.getElementById(\'canvas\');\r\nvar ctx = canvas.getContext(\'2d\');\r\n\r\ncanvas.width = window.innerWidth;\r\ncanvas.height = window.innerHeight;\r\n\r\nfunction render(points){\r\n	ctx.fillStyle = \"#140D0C\";\r\n	ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n	for(var i = 0;i < points.length;i++){\r\n		ctx.beginPath();\r\n		ctx.fillStyle = \"#281413\";\r\n		ctx.arc(points[i].x, points[i].y, 25, 0, Math.PI * 2, false);\r\n		ctx.fill();\r\n		ctx.closePath();\r\n\r\n		ctx.beginPath();\r\n		ctx.fillStyle = \"#F25E5C\";\r\n		ctx.arc(points[i].x, points[i].y, 10, 0, Math.PI * 2, false);\r\n		ctx.fill();\r\n		ctx.closePath();\r\n	}\r\n}\r\n\r\nfunction update(points){\r\n	collision(points);\r\n	for(var i = 0;i < points.length;i++){\r\n		points[i] = getPointNextPos(points[i]);\r\n	}\r\n}\r\n\r\nvar forces = [new force(-Math.PI / 2, 1)];\r\nvar myPoint = new rPoint(50, 50, new force(0, 15), forces);\r\nvar points = [myPoint];\r\n\r\nfunction controls(){\r\n	var speed = 2;\r\n	if(input.getAsyncKeyState(input.keyCode.W) || input.getAsyncKeyState(input.keyCode.UP)){\r\n		points[0].velocity = addForces(points[0].velocity, new force(Math.PI / 2, speed));\r\n	}\r\n	if(input.getAsyncKeyState(input.keyCode.A) ||input.getAsyncKeyState(input.keyCode.LEFT)){\r\n		points[0].velocity = addForces(points[0].velocity, new force(Math.PI, speed));\r\n	}\r\n	if(input.getAsyncKeyState(input.keyCode.D) || input.getAsyncKeyState(input.keyCode.RIGHT)){\r\n		points[0].velocity = addForces(points[0].velocity, new force(0, speed));\r\n	}\r\n	if(input.getAsyncKeyState(input.keyCode.S) ||\r\n  input.getAsyncKeyState(input.keyCode.DOWN)){\r\n		points[0].velocity = addForces(points[0].velocity, new force(-Math.PI / 2, speed));\r\n	}\r\n\r\n	//forces[0].angle = -direction(points[0], inputHandler.mouse);\r\n	//forces[0].magnitude = distance(points[0], inputHandler.mouse)/10;\r\n	//document.getElementById(\'info\').innerHTML = inputHandler.mouse.x + \", \" + inputHandler.mouse.y + \" | \" + points[0].x + \", \" + points[0].y;\r\n}\r\n\r\nfunction animate(){\r\n	controls();\r\n	update(points);\r\n	render(points);\r\n	window.requestAnimationFrame(animate);\r\n}\r\nanimate();\r\n\r\n\r\n\r\n', '2018-01-23 22:07:30', 1),
(5, 'Bezier curve of polar cosine wave - physics  ', '', 'var width = window.innerWidth;\r\nvar height = window.innerHeight;\r\n\r\nvar canvas = document.getElementById(\"canvas\");\r\ncanvas.style.background = \'#000\';\r\n\r\nvar ctx = canvas.getContext(\'2d\');\r\ncanvas.width = width;\r\ncanvas.height = height;\r\nctx.translate (canvas.width/2, canvas.height/2);\r\n\r\nvar toggleInfo = false;\r\n\r\nctx.fillStyle = \"#000000\";\r\n\r\nfunction force(magn, dir, weaken){\r\n	this.magn = magn;\r\n	this.dir = dir;\r\n\r\n	if(typeof(weaken) == \'undefined\') weaken = 1;\r\n	this.weaken = weaken;\r\n}\r\nfunction point(x, y){\r\n	this.x = x;\r\n	this.y = y;\r\n}\r\nfunction materialPoint(pos, velocity, forces, mass){\r\n	this.pos = pos;\r\n	this.forces = forces;\r\n	this.velocity = velocity;\r\n	this.mass = mass;\r\n}\r\nfunction spring(pointA, pointB, restDist, stiff){\r\n	this.pointA = pointA;\r\n	this.pointB = pointB;\r\n	this.restDist = restDist;\r\n	this.stiff = stiff;\r\n}\r\nfunction circle(point, rad, mass){\r\n	this.point = point;\r\n	this.rad = rad;\r\n}\r\n\r\nvar gravity = new force(1500, degToRad(270));\r\nvar mousePoint = new materialPoint(new point(0, 0),new force(0, 0), [], 10);\r\n\r\n// Data\r\nvar springs = [];\r\nvar objs = [];\r\nvar forces = [];\r\nvar points = [];\r\n\r\n\r\nvar vertex = mkMiddlePoitn(100, 50);\r\n\r\n\r\n// Functions\r\nfunction getDir(pointA, pointB){\r\n	//return Math.atan(-(pointB.y - pointA.y) / (pointB.x - pointA.x));\r\n	return -Math.atan2(pointB.x - pointA.x, pointB.y - pointA.y) + Math.PI/2;\r\n}\r\nfunction getDist(pointA, pointB){\r\n	return Math.sqrt((pointA.x - pointB.x) * (pointA.x - pointB.x) + (pointA.y - pointB.y) * (pointA.y - pointB.y));\r\n}\r\n\r\nfunction rand(min, max){\r\n	return Math.floor(Math.random() * max) + min;\r\n}\r\n\r\nfunction addForces(force1, force2){\r\n	var vect1X = Math.cos(force1.dir) * force1.magn\r\n	var vect1Y = Math.sin(force1.dir) * force1.magn\r\n\r\n	var vect2X = Math.cos(force2.dir) * force2.magn\r\n	var vect2Y = Math.sin(force2.dir) * force2.magn\r\n\r\n	var newX = vect1X + vect2X;\r\n	var newY = vect1Y + vect2Y;\r\n\r\n	var hypotenuse = Math.sqrt(newX * newX + newY * newY);\r\n	return new force(hypotenuse, Math.atan2(newY, newX));\r\n}\r\n\r\nfunction combineForces(forces){\r\n	var resForce = new force(0, 0);\r\n	for(var i = 0;i < forces.length;i++){\r\n		resForce = addForces(resForce, forces[i]);\r\n	}\r\n	return resForce;\r\n}\r\n\r\nfunction drawLine(pointA, pointB, size, color){\r\n	x1 = pointA.x;\r\n	y1 = pointA.y;\r\n	x2 = pointB.x;\r\n	y2 = pointB.y;\r\n	\r\n	y1 *= -1;\r\n	y2 *= -1;\r\n	\r\n	if(size == \"undefined\") size = 1;\r\n	if(color == \"undefined\") color = \"#ff0000\";\r\n\r\n	ctx.strokeStyle = color;\r\n	ctx.lineWidth = size;\r\n	ctx.beginPath();\r\n	ctx.moveTo(x1, y1);\r\n	ctx.lineTo(x2, y2);\r\n	ctx.stroke();\r\n	ctx.closePath();\r\n}\r\n\r\n\r\nfunction degToRad(deg){\r\n  return deg * Math.PI / 180;\r\n}\r\n\r\nvar mouse = new point(0, 0);\r\ncanvas.addEventListener(\'mousemove\', function(e){\r\n	mouse.x = e.clientX - canvas.width/2;\r\n	mouse.y = -(e.clientY - canvas.height/2);\r\n	mousePoint.pos.x = mouse.x;\r\n	mousePoint.pos.y = mouse.y;\r\n});\r\n\r\ndocument.getElementById(\'canvas\').addEventListener(\'click\', function(e){\r\n	toggleInfo = !toggleInfo;\r\n});\r\n\r\ncanvas.addEventListener(\'mousedown\', function(e){\r\n\r\n});\r\n\r\nfunction clear(){\r\n  ctx.clearRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);\r\n}\r\n\r\nfunction update(){\r\n	updateForces(forces);\r\n	updateSpringVelocity();\r\n	for(var i = 0;i < points.length;i++){\r\n		var allForces = combineForces(points[i].forces);\r\n		allForces.magn /= points[i].mass;\r\n\r\n		points[i].velocity = addForces(points[i].velocity, allForces);\r\n\r\n		// Air resistance\r\n		points[i].velocity.magn /= 1.4;\r\n\r\n		if(points[i].pos.y < -100){\r\n		}\r\n\r\n		points[i].pos.x += Math.cos(points[i].velocity.dir) * points[i].velocity.magn;\r\n		points[i].pos.y += Math.sin(points[i].velocity.dir) * points[i].velocity.magn;\r\n	}\r\n}\r\n\r\nfunction draw(){\r\n	clear();\r\n	var myCurve = mkCurve(vertex);\r\n	\r\n	//visualiseForces(forces);\r\n	//visualiseObjs(objs);\r\n	if(toggleInfo){\r\n		visualizeSpring();\r\n		visualiseVelocities(points);\r\n		\r\n		ctx.fillStyle = \"#39c0f6\";\r\n		ctx.fillRect(mouse.x - 5, -mouse.y - 5, 10, 10);\r\n	}\r\n	\r\n	drawLines(myCurve, \"rgba(0,0,0,0)\", 2);\r\n}\r\n\r\nfunction animate(){\r\n  update();\r\n  draw();\r\n}\r\n\r\nsetInterval(animate, 25);\r\n\r\nfunction visualiseForces(forces){\r\n  for(var i = 0;i < forces.length;i++){\r\n    drawLine(new point(0,0),\r\n             new point(\r\n                Math.cos(forces[i].dir) * forces[i].magn * 500, \r\n                -Math.sin(forces[i].dir) * forces[i].magn * 500)\r\n             );\r\n  }\r\n}\r\n\r\nfunction visualiseObjs(objs){\r\n	ctx.beginPath();\r\n	ctx.fillStyle = \"rgb(50,100,150)\";\r\n	for(var i = 0;i < objs.length;i++){\r\n		ctx.arc(objs[i].point.pos.x, -objs[i].point.pos.y, objs[i].rad, 0, 2 * Math.PI, false);\r\n		ctx.fill();\r\n		ctx.closePath();\r\n	}\r\n}\r\n\r\nfunction getTension(pointA, pointB, spring){\r\n	var newMagn = (getDist(pointA.pos, pointB.pos) - spring.restDist) * 5 * spring.stiff / pointA.mass;\r\n\r\n	var newDir = getDir(pointA.pos, pointB.pos);\r\n	return new force(newMagn, newDir);\r\n}\r\n\r\nfunction updateSpringVelocity(){\r\n	for(var i = 0;i < springs.length;i++){\r\n		if(getDist(springs[i].pointA.pos, springs[i].pointB.pos) > springs[i].restDist * springs[i].stiff){\r\n			//springs.splice(i, 1);\r\n			//continue;\r\n		}\r\n	\r\n		var ATension = getTension(springs[i].pointA, springs[i].pointB, springs[i]);\r\n		var BTension = getTension(springs[i].pointB, springs[i].pointA, springs[i]);\r\n\r\n		springs[i].pointA.velocity = addForces(springs[i].pointA.velocity, ATension);\r\n		springs[i].pointB.velocity = addForces(springs[i].pointB.velocity, BTension);\r\n	}\r\n}\r\n\r\nfunction visualizeSpring(){\r\n	for(var i = 0;i < springs.length;i++){\r\n		ctx.strokeStyle = \"rgba(\" + Math.round(Math.abs(getDist(springs[i].pointA.pos, springs[i].pointB.pos) - springs[i].restDist))*5 + \",0,50,1)\";\r\n		ctx.lineWidth = 0.5;\r\n		ctx.beginPath();\r\n		ctx.moveTo(springs[i].pointA.pos.x, -springs[i].pointA.pos.y);\r\n		ctx.lineTo(springs[i].pointB.pos.x, -springs[i].pointB.pos.y);\r\n		ctx.stroke();\r\n		ctx.closePath();\r\n   }\r\n}\r\n\r\nfunction visualiseVelocities(points){\r\n	for(var i = 0;i < points.length;i++){\r\n	drawLine(new point(points[i].pos.x, points[i].pos.y),\r\n			new point( points[i].pos.x + Math.cos(points[i].velocity.dir) * points[i].velocity.magn * 5,\r\n			points[i].pos.y + Math.sin(points[i].velocity.dir) * points[i].velocity.magn * 5), 0.5, \"#000FFF\");\r\n	}\r\n}\r\n\r\nfunction updateForces(forces){\r\n    for(var i = 0;i < forces.length;i++){\r\n      forces[i].magn /= forces[i].weaken;\r\n  	}\r\n}\r\n\r\nfunction mkRect(pointA, width, height){\r\n	var vertex1 = new materialPoint(new point(pointA.x, pointA.y), new force(0, 0), [gravity, ], 50);\r\n	var vertex2 = new materialPoint(new point(pointA.x + width, pointA.y), new force(0, 0), [gravity], 50);\r\n	var vertex3 = new materialPoint(new point(pointA.x + width, pointA.y + height), new force(0, 0), [gravity], 50);\r\n	var vertex4 = new materialPoint(new point(pointA.x, pointA.y + height), new force(0, 0), [gravity], 50);\r\n	\r\n	var diagonal = Math.sqrt(width * width + height * height);\r\n	\r\n	var connection1 = new spring(vertex1, vertex2, width, 5);\r\n	var connection2 = new spring(vertex2, vertex3, height, 5);\r\n	var connection3 = new spring(vertex3, vertex4, width, 5);\r\n	var connection4 = new spring(vertex4, vertex1, height, 5);\r\n	\r\n	var connection5 = new spring(vertex1, vertex3, diagonal, 5);\r\n	var connection6 = new spring(vertex2, vertex4, diagonal, 5);\r\n	\r\n	var connection7 = new spring(vertex1, mousePoint, 0, 37);\r\n	\r\n	points.push(vertex1, vertex2, vertex3, vertex4);\r\n	springs.push(connection1, connection2, connection3, connection4, connection5, connection6, connection7);\r\n	\r\n	return [vertex1.pos, vertex2.pos, vertex3.pos, vertex4.pos, vertex1.pos,];\r\n}\r\n\r\nfunction mkMiddlePoitn(size, segments){\r\n	var myPoints = [];\r\n	var myRealPoints = [];\r\n	for(var i = 0;i < Math.PI * 2;i += Math.PI * 2 / segments){\r\n		var fx = Math.cos(i*4);\r\n		var fyForce = new force(size * 50, getDir(new point(0, 0), new point(fx * Math.cos(i), fx * Math.sin(i))) );\r\n		var vertex1 = new materialPoint(new point(0,0), new force(10, 0), [fyForce,], 50);\r\n		\r\n		var connection1 = new spring(vertex1, mousePoint, size, 5);\r\n		springs.push(connection1);\r\n		\r\n		myPoints.push(vertex1);\r\n		myRealPoints.push(vertex1.pos);\r\n		points.push(vertex1);\r\n	}\r\n	//myRealPoints.push(myPoints[0].pos);\r\n	\r\n	for(var i = 1;i < myPoints.length;i++){\r\n		var connection1 = new spring(myPoints[i-1], myPoints[i], size, 5);\r\n		springs.push(connection1);\r\n	}\r\n	var connection1 = new spring(myPoints[0], myPoints[myPoints.length - 1], size, 5);\r\n	springs.push(connection1);\r\n	\r\n	return myRealPoints;\r\n}\r\n\r\n\r\n// Curves\r\nfunction drawCircles(curveData, color, size){\r\n	for(var i = 0;i < curveData.length;i++){\r\n		ctx.fillStyle = color\r\n		ctx.beginPath();\r\n		ctx.arc(curveData[i].x, curveData[i].y, size, 0, 2 * Math.PI, false);\r\n		ctx.closePath();\r\n		ctx.fill();\r\n	}\r\n}\r\n\r\nfunction drawLines(curveData, color, size){\r\n	for(var i = 1;i < curveData.length;i++){\r\n		//var pointA = new point(curveData[i - 1].x + rand(0,10)/5, curveData[i - 1].y + rand(0,10)/5);\r\n		//var pointB = new point(curveData[i].x + rand(0,10)/5, curveData[i].y + rand(0,10)/5);\r\n		drawLine(curveData[i - 1], curveData[i], size, color);\r\n	}\r\n}\r\n\r\nfunction visualiseCurves(curves, color, sizze){\r\n	for(var i = 1;i < curves.length;i++){\r\n		drawLines(curves[i], color, size);\r\n	}\r\n}\r\n\r\nvar iAnim = 1;\r\nfunction mkCurve(curveForm){\r\n	var localTimeStep = 5;\r\n	var curveRes = [];\r\n	\r\n	for(var localTime = 0;localTime <= 100;localTime += localTimeStep){\r\n		var myPointArr = curveForm;\r\n		while(myPointArr.length > 1){\r\n			var updateArr = [];\r\n			for(var i = 1;i < myPointArr.length;i++){\r\n				updateArr.push(getCurvePoint(myPointArr[i - 1], myPointArr[i], localTime));\r\n				\r\n				var color = \"#00ffff\";\r\n				if(Math.abs(iAnim - i) < 5){\r\n					color = \"#FF0080\";\r\n				}\r\n				if(curveRes.length == 2){\r\n					drawLine(myPointArr[i - 1], myPointArr[i], 0.3, color);\r\n				}\r\n			}\r\n			myPointArr = updateArr;\r\n		}\r\n		curveRes.push(myPointArr[0]);\r\n	}\r\n	iAnim = (iAnim + 1) % 50;\r\n	\r\n	return curveRes;\r\n}\r\n\r\nfunction getCurvePoint(pointA, pointB, time){\r\n	var xPos = pointA.x + (getDist(pointA, pointB) * time/100) * Math.cos(getDir(pointA, pointB));\r\n	var yPos = pointA.y + (getDist(pointA, pointB) * time/100) * Math.sin(getDir(pointA, pointB));\r\n	return new point(xPos, yPos);\r\n}\r\n\r\n\r\n\r\n', '2018-01-23 22:11:01', 1),
(6, 'Title', '', 'var width = window.innerWidth;\r\nvar height = window.innerHeight;\r\n\r\nvar canvas = document.getElementById(\"canvas\");\r\nvar ctx = canvas.getContext(\'2d\');\r\ncanvas.width = width;\r\ncanvas.height = height;\r\n\r\nctx.fillStyle = \"#ff0000\";\r\n\r\nfunction myFunc(x){\r\n   return 1/Math.tan(4*x+Math.cos(param/150)*5)*Math.cos(param/50)*70+150;\r\n}\r\n\r\nfunction myFunc2(x){\r\n  return Math.tan(4*x+Math.cos(param/150)*5)*Math.tan(param/50)*100+250;\r\n}\r\n\r\nfunction myFunc3(x, p){\r\n  return Math.tan(30*x)*10+200;\r\n}\r\n\r\nvar param = 0;\r\nfunction graphPolar(func, color){\r\n  for(var x = 0;x < 2 * Math.PI;x+=0.01){\r\n    var color = Math.round(((Math.cos(param/200)+1)/2)*111111+888888);\r\n    color = \"ff3366\";\r\n    ctx.fillStyle = \"#\" + color;\r\n    ctx.fillRect(Math.cos(x) * func(x) + canvas.width/2, \r\n           Math.sin(x) * func(x) + canvas.height/2 ,1,1);\r\n  }\r\n}\r\nfunction clear(){\r\n  //ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n  ctx.fillStyle = \"rgba(255,255,255,.05)\";\r\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n}\r\n\r\n\r\nfunction paramMover(){\r\n	clear();\r\n  param++;\r\n  graphPolar(myFunc);\r\n  graphPolar(myFunc2);\r\n  //graphPolar(myFunc3);\r\n}\r\n\r\nsetInterval(paramMover, 10);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '2018-01-23 22:15:31', 1),
(7, 'Julia set ', '', 'let vShader = `\r\n            attribute vec3 position;\r\n \r\n            void main() {\r\n \r\n                gl_Position = vec4( position, 1.0 );\r\n \r\n            }\r\n`;\r\n \r\nlet fShader = `\r\n            uniform float time;\r\n            uniform vec2 resolution;\r\n\r\n            #define ITERATIONS 32\r\n\r\n            vec2 func(vec2 m, vec2 n) {\r\n                return vec2(m.x * m.x - m.y * m.y + n.x, 2.0 * m.x * m.y + n.y);\r\n            }\r\n\r\n            vec2 iterate(vec2 x, vec2 c) {\r\n                for (int i = 0;i < ITERATIONS;i++) {\r\n                    c = func(c, x);\r\n                }\r\n\r\n                return c;\r\n            }\r\n \r\n            void main( void ) {\r\n                vec2 position = - 1.0 + 2.0 * gl_FragCoord.xy / resolution.x + vec2(0.0, 0.5);\r\n                \r\n                vec2 origin = vec2(0);\r\n                float zoom = 2.0;\r\n\r\n                position *= zoom;\r\n                position -= origin;\r\n\r\n                float t = time / 2.0;\r\n                vec2 c = vec2(-0.8, 0.156);\r\n                vec2 result = iterate(vec2(sin(t * 1.3) / 10.0, sin(t) / 10.0) + c, position);\r\n                float len = length(result);\r\n                result *= sin(result.x * result.y * 32.1);\r\n                gl_FragColor = vec4(abs(result.x) * 15.0, abs(result.y) * 2.0, max(len, 0.0), 1.0);\r\n            }\r\n`;\r\n\r\n/**\r\n * Provides requestAnimationFrame in a cross browser way.\r\n * paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n */\r\nwindow.requestAnimationFrame = window.requestAnimationFrame || ( function() {\r\n\r\n    return  window.webkitRequestAnimationFrame ||\r\n            window.mozRequestAnimationFrame ||\r\n            window.oRequestAnimationFrame ||\r\n            window.msRequestAnimationFrame ||\r\n            function(  callback, element ) {\r\n                window.setTimeout( callback, 1000 / 60 );\r\n            };\r\n\r\n})();\r\n\r\n\r\nvar canvas, \r\n    gl, \r\n    buffer, \r\n    vertex_shader, fragment_shader, \r\n    currentProgram,\r\n    vertex_position,\r\n    timeLocation,\r\n    resolutionLocation,\r\n    parameters = {  start_time  : new Date().getTime(), \r\n                    time        : 0, \r\n                    screenWidth : 0, \r\n                    screenHeight: 0 };\r\n\r\ninit();\r\nanimate();\r\n\r\nfunction init() {\r\n\r\n    vertex_shader = vShader;\r\n    fragment_shader = fShader;\r\n\r\n\r\n\r\n    canvas = document.querySelector( \'canvas\' );\r\n\r\n\r\n    // Initialise WebGL\r\n\r\n    try {\r\n\r\n        gl = canvas.getContext( \'experimental-webgl\' );\r\n\r\n    } catch( error ) { }\r\n\r\n    if ( !gl ) {\r\n\r\n        throw \"cannot create webgl context\";\r\n\r\n    }\r\n\r\n    // Create Vertex buffer (2 triangles)\r\n\r\n    buffer = gl.createBuffer();\r\n    gl.bindBuffer( gl.ARRAY_BUFFER, buffer );\r\n    gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] ), gl.STATIC_DRAW );\r\n\r\n    // Create Program\r\n\r\n    currentProgram = createProgram( vertex_shader, fragment_shader );\r\n\r\n    timeLocation = gl.getUniformLocation( currentProgram, \'time\' );\r\n    resolutionLocation = gl.getUniformLocation( currentProgram, \'resolution\' );\r\n\r\n}\r\n\r\nfunction createProgram( vertex, fragment ) {\r\n\r\n    var program = gl.createProgram();\r\n\r\n    var vs = createShader( vertex, gl.VERTEX_SHADER );\r\n    var fs = createShader( \'#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\n\' + fragment, gl.FRAGMENT_SHADER );\r\n\r\n    if ( vs == null || fs == null ) return null;\r\n\r\n    gl.attachShader( program, vs );\r\n    gl.attachShader( program, fs );\r\n\r\n    gl.deleteShader( vs );\r\n    gl.deleteShader( fs );\r\n\r\n    gl.linkProgram( program );\r\n\r\n    if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {\r\n\r\n        alert( \"ERROR:\\n\" +\r\n        \"VALIDATE_STATUS: \" + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + \"\\n\" +\r\n        \"ERROR: \" + gl.getError() + \"\\n\\n\" +\r\n        \"- Vertex Shader -\\n\" + vertex + \"\\n\\n\" +\r\n        \"- Fragment Shader -\\n\" + fragment );\r\n\r\n        return null;\r\n\r\n    }\r\n\r\n    return program;\r\n\r\n}\r\n\r\nfunction createShader( src, type ) {\r\n\r\n    var shader = gl.createShader( type );\r\n\r\n    gl.shaderSource( shader, src );\r\n    gl.compileShader( shader );\r\n\r\n    if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {\r\n\r\n        alert( ( type == gl.VERTEX_SHADER ? \"VERTEX\" : \"FRAGMENT\" ) + \" SHADER:\\n\" + gl.getShaderInfoLog( shader ) );\r\n        return null;\r\n\r\n    }\r\n\r\n    return shader;\r\n\r\n}\r\n\r\nfunction resizeCanvas( event ) {\r\n\r\n    if ( canvas.width != canvas.clientWidth ||\r\n         canvas.height != canvas.clientHeight ) {\r\n\r\n        canvas.width = canvas.clientWidth;\r\n        canvas.height = canvas.clientHeight;\r\n\r\n        parameters.screenWidth = canvas.width;\r\n        parameters.screenHeight = canvas.height;\r\n\r\n        gl.viewport( 0, 0, canvas.width, canvas.height );\r\n\r\n    }\r\n\r\n}\r\n\r\nfunction animate() {\r\n\r\n    resizeCanvas();\r\n    render();\r\n    requestAnimationFrame( animate );\r\n\r\n}\r\n\r\nfunction render() {\r\n\r\n    if ( !currentProgram ) return;\r\n\r\n    parameters.time = new Date().getTime() - parameters.start_time;\r\n\r\n    gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\r\n\r\n    // Load program into GPU\r\n\r\n    gl.useProgram( currentProgram );\r\n\r\n    // Set values to program variables\r\n\r\n    gl.uniform1f( timeLocation, parameters.time / 1000 );\r\n    gl.uniform2f( resolutionLocation, parameters.screenWidth, parameters.screenHeight );\r\n\r\n    // Render geometry\r\n\r\n    gl.bindBuffer( gl.ARRAY_BUFFER, buffer );\r\n    gl.vertexAttribPointer( vertex_position, 2, gl.FLOAT, false, 0, 0 );\r\n    gl.enableVertexAttribArray( vertex_position );\r\n    gl.drawArrays( gl.TRIANGLES, 0, 6 );\r\n    gl.disableVertexAttribArray( vertex_position );\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n', '2018-01-23 22:15:55', 1);
INSERT INTO `snippets` (`id`, `name`, `description`, `code`, `date_created`, `user_id`) VALUES
(8, 'Lagrange Interpolating Polynomial', '', 'class Event {\r\n\r\n    constructor() {\r\n        this.eventInstances = [];\r\n        this.attach = {}\r\n    }\r\n\r\n    create(name, condition, contextProvider) {\r\n        let binds = [];\r\n        this.eventInstances.push({ binds, condition, contextProvider, name });\r\n        this.attach[name] = this.buildAttachobject(binds);\r\n        \r\n        return this;\r\n    }\r\n\r\n    buildAttachobject(binds) {\r\n        return {\r\n            to: (elements, handler, antiHandler) => {\r\n                binds.push({ elements, handler, antiHandler });\r\n                return this;\r\n            }\r\n        };\r\n    }\r\n\r\n    trigger() {\r\n        this.self = this;\r\n        this.eventInstances.forEach(({ binds, condition, contextProvider }) => {\r\n            var context = contextProvider && contextProvider();\r\n            binds.forEach(({ elements, handler, antiHandler }) =>\r\n                this.invokeBindsHandlers(\r\n                    elements, condition,\r\n                    handler, antiHandler, context\r\n                ));\r\n        });\r\n    }\r\n\r\n    invokeBindsHandlers(elements, condition, handler, antiHandler, context) {\r\n        elements.forEach((element) => {\r\n            if(condition(element, context)) {\r\n                handler(element, context);\r\n            } else {\r\n                antiHandler && antiHandler(element, context);\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n\r\nclass IO {\r\n\r\n    constructor() {\r\n        this.mouse = {\r\n            x: 0,\r\n            y: 0,\r\n            dx: 0,\r\n            dy: 0,\r\n            down: false,\r\n            out: true\r\n        };\r\n        this.mouseBindings = {\r\n            scroll: [],\r\n            click: [],\r\n            dblclick: []\r\n        };\r\n        this.keyBindings = {};\r\n        this.registerBindings();\r\n    }\r\n\r\n    onMouse(event, handler) {\r\n        if(!this.mouseBindings[event]) {\r\n            this.mouseBindings[event] = [];\r\n        }\r\n        this.mouseBindings[event].push(handler);\r\n\r\n        return this;\r\n    }\r\n\r\n    onKey(key, handler) {\r\n        this.keyBindings[key] = { isDown: false, handler };\r\n\r\n        return this;\r\n    }\r\n\r\n    trigger() {\r\n        for(let key in this.keyBindings){\r\n            if(this.keyBindings[key].isDown){\r\n                this.keyBindings[key].handler();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    registerBindings() {\r\n        let me = this\r\n        let clickHandler = (handler, event) => handler({ x: event.x, y: event.y });\r\n\r\n        window.addEventListener(\'mousewheel\', (event) => {\r\n            me.mouseBindings.scroll.forEach((handler =>\r\n                handler(Math.sign(event.wheelDelta))));\r\n        });\r\n\r\n        window.addEventListener(\'click\', (event) =>\r\n            me.mouseBindings.click.forEach((handler) => clickHandler(handler, event)));\r\n\r\n        window.addEventListener(\'dblclick\', (event) =>\r\n            me.mouseBindings.dblclick.forEach((handler) => clickHandler(handler, event)));\r\n\r\n\r\n        window.addEventListener(\'keydown\', (event) => {\r\n            if(me.keyBindings[event.key]) {\r\n                me.keyBindings[event.key].isDown = true;\r\n            }\r\n        });\r\n\r\n        window.addEventListener(\'mousemove\', (event) => {\r\n            me.mouse.dx = event.movementX;\r\n            me.mouse.dy = event.movementY;\r\n            me.mouse.x = event.x;\r\n            me.mouse.y = event.y;\r\n        });\r\n\r\n        window.addEventListener(\'mousedown\', () => me.mouse.down = true);\r\n        window.addEventListener(\'mouseup\', () => me.mouse.down = false);\r\n        \r\n        window.document.addEventListener(\'mouseover\', () => me.mouse.out = false);\r\n        window.document.addEventListener(\'mouseout\', () => me.mouse.out = true);\r\n\r\n        window.addEventListener(\'keyup\', (event) => {\r\n            if(me.keyBindings[event.key]) {\r\n                me.keyBindings[event.key].isDown = false;\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n\r\nclass Plotter {\r\n\r\n    constructor(ctx, config = {\r\n        from: -500, to: 500,\r\n        color: \'#f70e75\',\r\n        size: 10,\r\n        stepSize: 9,\r\n        scale: 20,\r\n        origin: { x: 0, y: 0 }\r\n    }) {\r\n        this.ctx = ctx;\r\n        this.config = config;\r\n        this.functionBuilders = [];\r\n        this.points = [];\r\n    }\r\n\r\n    addFunctionBuilders(functions) {\r\n        this.functionBuilders = this.functionBuilders.concat(functions);\r\n        return this;\r\n    }\r\n\r\n    addScaledPoint(point) {\r\n        return this.addPoint({\r\n            x: point.x / this.config.scale,\r\n            y: point.y / this.config.scale\r\n        });\r\n    }\r\n\r\n    addPoint(point) {\r\n        this.points.push(point);\r\n        return this;\r\n    }\r\n\r\n    show() {\r\n        this.functionBuilders.forEach((builder) => {\r\n            this.plotFunction(builder());\r\n        }, this);\r\n\r\n        this.points.forEach((point) => {\r\n            this.drawPoint(\r\n                point.x * this.config.scale,\r\n                point.y * this.config.scale,\r\n                point.style || {}\r\n            );\r\n        }, this);\r\n        \r\n        return this;\r\n    }\r\n\r\n    plotFunction(func) {\r\n        let fromY = func(this.config.from / this.config.scale + this.config.origin.x) * this.config.scale + this.config.origin.y;\r\n        for (let x = this.config.from + this.config.stepSize;x < this.config.to;x += this.config.stepSize) {\r\n            let toX = x + this.config.origin.x;\r\n            let fromX = toX - this.config.stepSize;\r\n            let toY = func(x / this.config.scale + this.config.origin.x) * this.config.scale  + this.config.origin.y;\r\n\r\n            this.drawLine(fromX, fromY, toX, toY, func.style || {});\r\n            fromY = toY;\r\n        }\r\n    }\r\n\r\n    drawLine(fromX, fromY, toX, toY, style) {\r\n        this.ctx.strokeStyle = style.color || this.config.color;\r\n        this.ctx.lineWidth = style.size || this.config.size;\r\n\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(fromX, -fromY);\r\n        this.ctx.lineTo(toX, -toY);\r\n        this.ctx.stroke();\r\n        this.ctx.closePath();\r\n        this.drawPoint(fromX, fromY, { size: this.config.size / 2 });\r\n\r\n        return this;\r\n    }\r\n\r\n    drawPoint(x, y, style) {\r\n        this.ctx.fillStyle = style.color || this.config.color;\r\n\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, -y, style.size || this.config.size, 0, Math.PI * 2);\r\n        this.ctx.closePath();\r\n        this.ctx.fill();\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    clear(width, height) {\r\n        this.ctx.fillStyle = \'#1D1E45\';\r\n        this.ctx.fillRect(-width / 2, -height / 2, width, height);\r\n        return this;\r\n    }\r\n\r\n}\r\n\r\nclass Lagrange {\r\n\r\n    constructor(points = []) {\r\n        this.polynomial = (x) => 1;\r\n        this.setPoints(points);\r\n    }\r\n\r\n    setPoints(points) {\r\n        this.points = points;\r\n        this.build();\r\n\r\n        return this;\r\n    }\r\n\r\n    getBuilder() {\r\n        return () => this.polynomial;\r\n    }\r\n\r\n    fullPolynomial(roots) {\r\n        return (x) => roots.reduce((product, xi) =>\r\n            product * (x - xi), 1);\r\n    }\r\n\r\n    splitPolynomial(i, px) {\r\n        let left = this.fullPolynomial(px.slice(0, i)),\r\n            right = this.fullPolynomial(px.slice(i + 1, px.length));\r\n\r\n        return (x) => left(x) * right(x);\r\n    }\r\n\r\n    build() {\r\n        let px = this.points.map((p) => p.x),\r\n            divisor = px.map((x, i) =>\r\n                this.splitPolynomial(i, px)(x), this),\r\n            me = this;\r\n\r\n        return this.polynomial = (x) => \r\n            this.points.map((p) => p.y).reduce((sum, y, i) =>\r\n                sum + y * me.splitPolynomial(i, px)(x) / divisor[i], 0);\r\n    }\r\n\r\n}\r\n\r\n\r\n let [ canvas, ctx, width, height ] = ((canvasId) => {\r\n                let canvas = document.getElementById(canvasId);\r\n                [ canvas.width, canvas.height ] = [ innerWidth, innerHeight ];\r\n\r\n                let ctx = canvas.getContext(\'2d\');\r\n                ctx.translate(canvas.width / 2, canvas.height / 2);\r\n\r\n                return [ canvas, ctx, canvas.width, canvas.height ];\r\n            })(\'canvas\');\r\n\r\n            let plotter = new Plotter(ctx),\r\n                io = new IO(),\r\n                lagrange = new Lagrange(plotter.points),\r\n                event = new Event(),\r\n                \r\n                translate = ({ x, y, down }) => ({\r\n                    x: (x - width / 2) / plotter.config.scale,\r\n                    y: (-y + height / 2) / plotter.config.scale,\r\n                    down: down\r\n                }),\r\n                distance = (point, { x, y }) => {\r\n                    let [ dx, dy ] = [ point.x - x, point.y - y ];\r\n                    return Math.sqrt(dx * dx + dy * dy);\r\n                },\r\n                draggedElement = undefined,\r\n                frame = 0;\r\n\r\n\r\n            event\r\n                .create(\'hover\', (point, mouse) =>\r\n                    distance(point, mouse) < 1,\r\n                    () => translate(io.mouse))\r\n\r\n                .create(\'move\', (point, mouse) => {\r\n                    let drag = mouse.down && distance(point, mouse) < 1;\r\n                    if(drag){\r\n                        draggedElement = point;\r\n                    } else if(!mouse.down) {\r\n                        draggedElement = false;\r\n                    }\r\n\r\n                    return mouse.down;\r\n                }, () => translate(io.mouse));\r\n\r\n\r\n            event\r\n                .attach.hover.to(plotter.points,\r\n                    (point) => point.style = { color: \'#ffd6d6\' },\r\n                    (point) => point.style = { color: \'#ffffdd\' }\r\n                )\r\n                .attach.move.to(plotter.points, (point, mouse) => {\r\n                    draggedElement.style = { color: \'#ffa5a5\' };\r\n                    draggedElement.x = mouse.x;\r\n                    draggedElement.y = mouse.y;\r\n                    lagrange.build();\r\n                });\r\n\r\n            io\r\n                .onKey(\'+\', () => plotter.config.scale *= 1.1)\r\n                .onKey(\'-\', () => plotter.config.scale /= 1.1)\r\n                .onMouse(\'scroll\', (direction) => plotter.config.scale *= 1.2 ** direction)\r\n                .onMouse(\'dblclick\', (point) => {\r\n                    plotter.addPoint(translate(point));\r\n                    lagrange.build();\r\n                });\r\n\r\n            plotter.addFunctionBuilders([lagrange.getBuilder()]);\r\n\r\n            plotter.points.push(\r\n                { x: -20, y: 10 },\r\n                { x: -10, y: -10 },\r\n                { x: -0, y: 5 },\r\n                { x: 10, y: 10 },\r\n                { x: 20, y: 0 }\r\n            );\r\n            plotter.points.forEach((point) => {\r\n                point.y = Math.random() * 15 - 7.5;\r\n            });\r\n            lagrange.build();\r\n\r\n            (function draw() {\r\n                event.trigger();\r\n                io.trigger();\r\n                plotter\r\n                    .clear(width, height)\r\n                    .show();\r\n\r\n                if(io.mouse.out) {\r\n                    plotter.points.forEach((point) => {\r\n                        point.y += Math.sin(point.x + frame / 50) / 10;\r\n                        lagrange.build();\r\n                    });\r\n                }\r\n\r\n                frame++;\r\n                requestAnimationFrame(draw);\r\n            })();', '2018-01-23 22:18:36', 1),
(9, 'Physics - random graph', '', 'var width = window.innerWidth;\nvar height = window.innerHeight;\n\nvar canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\'2d\');\ncanvas.width = width;\ncanvas.height = height;\nctx.translate (canvas.width/2, canvas.height/2);\n\nctx.fillStyle = \"#ff0000\";\n\nfunction force(magn, dir, weaken){\n	this.magn = magn;\n  this.dir = dir;\n\n  if(typeof(weaken) == \'undefined\') weaken = 1;\n  this.weaken = weaken;\n\n}\nfunction point(x, y){\n  this.x = x;\n  this.y = y;\n}\nfunction materialPoint(pos, velocity, forces, mass){\n  this.pos = pos;\n  this.forces = forces;\n  this.velocity = velocity;\n  this.mass = mass;\n}\nfunction spring(pointA, pointB, restDist, stiff){\n  this.pointA = pointA;\n  this.pointB = pointB;\n  this.restDist = restDist;\n  this.stiff = stiff;\n}\nfunction circle(point, rad, mass){\n  this.point = point;\n  this.rad = rad;\n}\n\nvar gravity = new force(0, degToRad(0));\nvar push = new force(0.1, degToRad(120));\nvar combined = addForces(gravity, push);\n\nvar ballPos = new materialPoint(new point(0, 0), new force(0, 0), [gravity ], 5000);\nvar myPoint = new materialPoint(new point(0, 150),new force(1, 0), [push, gravity ], 5000);\nvar mousePoint = new materialPoint(new point(0, 0),new force(0, 0), [], 1);\nvar ball = new circle(ballPos, 20, 100);\nvar ball2 = new circle(myPoint, 5, 50);\n\nvar mouseSprings = new spring(myPoint, mousePoint, 10, 150);\nvar springs = [new spring(myPoint, ballPos, 100, 150), mouseSprings];\n\nvar objs = [ball, ball2, ];\nvar forces = [gravity, push, combined, ];\nvar points = [ballPos,myPoint, ];\n\n\nfor(var i = 0; i < 2*Math.PI;i += 0.5){\n	var myObjsPoint = new materialPoint(new point(Math.cos(i)*10, Math.sin(i)*10), new force(1, 0),[new force(rand(500, 1000), rand(0,628)/100) ], 5000);\n	var myObj = new circle(myObjsPoint, rand(1,20), 100);\n\n	var connector = new spring(myObjsPoint,points[rand(0,points.length)], rand(20,100), 1000);\n\n	objs.push(myObj);\n	points.push(myObjsPoint);\n	springs.push(connector);\n}\n\n\nfunction getDir(pointA, pointB){\n  //return Math.atan(-(pointB.y - pointA.y) / (pointB.x - pointA.x));\n  return -Math.atan2(pointB.x - pointA.x, \n                    pointB.y - pointA.y) + Math.PI/2;\n}\nfunction getDist(pointA, pointB){\n  return Math.sqrt((pointA.x - pointB.x) * (pointA.x - pointB.x) +\n                   (pointA.y - pointB.y) * (pointA.y - pointB.y));\n}\n\nfunction rand(min, max){\n	return Math.floor(Math.random() * max) + min;\n}\n\nfunction addForces(force1, force2){\n  var vect1X = Math.cos(force1.dir) * force1.magn\n  var vect1Y = Math.sin(force1.dir) * force1.magn\n\n  var vect2X = Math.cos(force2.dir) * force2.magn\n  var vect2Y = Math.sin(force2.dir) * force2.magn\n\n  var newX = vect1X + vect2X;\n  var newY = vect1Y + vect2Y;\n\n  var hypotenuse = Math.sqrt(newX * newX + newY * newY);\n  return new force(hypotenuse, Math.atan2(newY, newX));\n}\n\nfunction combineForces(forces){\n  var resForce = new force(0, 0);\n  for(var i = 0;i < forces.length;i++){\n    resForce = addForces(resForce, forces[i]);\n  }\n  return resForce;\n}\n\nfunction drawLine(pointA, pointB){\n  x1 = pointA.x;\n  y1 = pointA.y;\n  x2 = pointB.x;\n  y2 = pointB.y;\n\n  ctx.strokeStyle = \"#ff0000\";\n  ctx.fillStyle = \"#0000ff\";\n\n  ctx.lineWidth = 1;\n  ctx.beginPath();\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n  ctx.stroke();\n  ctx.closePath();\n\n  ctx.fillRect(x2 - 2.5, y2 - 2.5, 5, 5);\n}\n\nfunction degToRad(deg){\n  return deg * Math.PI / 180;\n}\n\nvar mouse = new point(0, 0);\ncanvas.addEventListener(\'mousemove\', function(e){\n 	mouse.x = e.clientX - canvas.width/2;\n  mouse.y = -(e.clientY - canvas.height/2);\n  mousePoint.pos.x = mouse.x;\n  mousePoint.pos.y = mouse.y;\n});\n\ncanvas.addEventListener(\'mousedown\', function(e){\n\n});\n\nfunction clear(){\n  ctx.clearRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);\n}\n\nfunction update(){\n  updateForces(forces);\n  updateSpringVelocity();\n  for(var i = 0;i < points.length;i++){\n  	var allForces = combineForces(points[i].forces);\n    allForces.magn /= points[i].mass;\n\n    points[i].velocity = addForces(points[i].velocity, allForces);\n    var resVelocity = points[i].velocity;\n\n    // Air resistance\n    points[i].velocity.magn /= 1.03;\n\n    points[i].pos.x += Math.cos(resVelocity.dir) * resVelocity.magn;\n    points[i].pos.y -= Math.sin(resVelocity.dir) * resVelocity.magn;\n  }\n\n	combined = addForces(gravity, push);\n}\n\nfunction draw(){\n  clear();\n  //visualiseForces(forces);\n  visualizeSpring();\n  visualiseObjs(objs);\n  //visualiseVelocities(points);\n\n  ctx.fillRect(mouse.x - 5, -mouse.y - 5, 10, 10);\n  forces = [gravity, push, combined,];\n}\n\nfunction animate(){\n  update();\n  draw();\n}\n\nsetInterval(animate, 25);\n\nfunction visualiseForces(forces){\n  for(var i = 0;i < forces.length;i++){\n    drawLine(new point(0,0),\n             new point(\n                Math.cos(forces[i].dir) * forces[i].magn * 500, \n                -Math.sin(forces[i].dir) * forces[i].magn * 500)\n             );\n  }\n}\n\nfunction visualiseObjs(objs){\n	ctx.beginPath();\n  ctx.fillStyle = \"rgb(50,100,150)\";\n  for(var i = 0;i < objs.length;i++){\n    ctx.arc(objs[i].point.pos.x, -objs[i].point.pos.y, objs[i].rad, \n            0, 2 * Math.PI, false);\n    ctx.fill();\n    ctx.closePath();\n  }\n}\n\nfunction getTension(pointA, pointB, spring){\n  var newMagn = (getDist(pointA.pos, pointB.pos) - spring.restDist) * \n      					spring.stiff / pointA.mass;\n  var newDir = -getDir(pointA.pos, pointB.pos);\n  return new force(newMagn, newDir);\n}\n\nfunction updateSpringVelocity(){\n  for(var i = 0;i < springs.length;i++){\n    var ATension = getTension(springs[i].pointA, springs[i].pointB, springs[i]);\n    var BTension = getTension(springs[i].pointB, springs[i].pointA, springs[i]);\n\n  	springs[i].pointA.velocity = addForces(springs[i].pointA.velocity, ATension);\n  	springs[i].pointB.velocity =  addForces(springs[i].pointB.velocity, BTension);\n  }\n}\n\nfunction visualizeSpring(){\n	for(var i = 0;i < springs.length;i++){\n		ctx.strokeStyle = \"rgba(\" + Math.round(Math.abs(getDist(springs[i].pointA.pos, springs[i].pointB.pos) - springs[i].restDist))*5 + \",0,50,1)\";\n		ctx.lineWidth = 0.5;\n		ctx.beginPath();\n		ctx.moveTo(springs[i].pointA.pos.x, -springs[i].pointA.pos.y);\n		ctx.lineTo(springs[i].pointB.pos.x, -springs[i].pointB.pos.y);\n		ctx.stroke();\n		ctx.closePath();\n   }\n}\n\nfunction visualiseVelocities(points){\n  for(var i = 0;i < points.length;i++){\n    drawLine(new point(points[i].pos.x, -points[i].pos.y),\n     new point(\n    points[i].pos.x + Math.cos(points[i].velocity.dir) * points[i].velocity.magn * 50,\n    -points[i].pos.y + Math.sin(points[i].velocity.dir) * points[i].velocity.magn * 50));\n  }\n}\n\nfunction updateForces(forces){\n    for(var i = 0;i < forces.length;i++){\n      forces[i].magn /= forces[i].weaken;\n  	}\n}\n\n\n\n\n\n\n\n\n', '2018-01-23 22:19:04', 1),
(10, 'Title', '', '\r\nvar width = window.innerWidth;\r\nvar height = window.innerHeight;\r\n\r\nvar canvas = document.getElementById(\"canvas\");\r\nvar ctx = canvas.getContext(\'2d\');\r\ncanvas.width = width;\r\ncanvas.height = height;\r\nctx.translate (canvas.width/2, canvas.height/2);\r\n\r\nvar bezieForm = [new point(0,2), new point(0,3), new point(0,4), new point(0,5), new point(0,6), new point(0,7), ];\r\nvar bezieCurve = []\r\n\r\nfor(var i = 0;i <= Math.PI * 2;i += 0.2){\r\n	var fx = Math.tan(i*8	) * 200;\r\n	//bezieForm.push(new point(fx * Math.cos(i), fx * Math.sin(i)));\r\n}\r\n\r\nfunction animate(){\r\n	clear();\r\n	bezieCurve = mkCurve(bezieForm);\r\n	\r\n	drawLines(bezieCurve, \"#000fff\", 2);\r\n	\r\n	//drawLines(bezieForm, \"#333\", 1);\r\n	//drawCircles(bezieForm, \"#c3c3c3\", 3);\r\n	\r\n	if(mouseDown){\r\n		bezieForm.push(new point(mouse.x, mouse.y));\r\n		bezieForm.splice(0, 1)\r\n	}\r\n	//draggablePoints(bezieForm, 5);\r\n}\r\n\r\nsetInterval(animate, 25);\r\n\r\n\r\n// Curve stuff\r\nfunction drawCircles(curveData, color, size){\r\n	for(var i = 0;i < curveData.length;i++){\r\n		ctx.fillStyle = color\r\n		ctx.beginPath();\r\n		ctx.arc(curveData[i].x, curveData[i].y, size, 0, 2 * Math.PI, false);\r\n		ctx.closePath();\r\n		ctx.fill();\r\n	}\r\n}\r\n\r\nfunction drawLines(curveData, color, size){\r\n	for(var i = 1;i < curveData.length;i++){\r\n		//var pointA = new point(curveData[i - 1].x + rand(0,10)/5, curveData[i - 1].y + rand(0,10)/5);\r\n		//var pointB = new point(curveData[i].x + rand(0,10)/5, curveData[i].y + rand(0,10)/5);\r\n		drawLine(curveData[i - 1], curveData[i], size, color);\r\n	}\r\n}\r\n\r\nfunction mkCurve(curveForm){\r\n	var localTimeStep = 2;\r\n	var curveRes = [];\r\n	\r\n	for(var localTime = 0;localTime <= 100;localTime += localTimeStep){\r\n		var myPointArr = curveForm;\r\n		while(myPointArr.length > 1){\r\n			var updateArr = [];\r\n			for(var i = 1;i < myPointArr.length;i++){\r\n				updateArr.push(getCurvePoint(myPointArr[i - 1], myPointArr[i], localTime));\r\n				//drawLine(myPointArr[i - 1], myPointArr[i], 0.1, \"#666\");\r\n			}\r\n			myPointArr = updateArr;\r\n		}\r\n		curveRes.push(myPointArr[0]);\r\n	}\r\n	\r\n	return curveRes;\r\n}\r\n\r\nfunction getCurvePoint(pointA, pointB, time){\r\n	var xPos = pointA.x + (getDist(pointA, pointB) * time/100) * Math.cos(getDir(pointA, pointB));\r\n	var yPos = pointA.y + (getDist(pointA, pointB) * time/100) * Math.sin(getDir(pointA, pointB));\r\n	return new point(xPos, yPos);\r\n}\r\n\r\n\r\n// Old Stuff\r\nvar associatedPoint = null;\r\nfunction draggablePoints(points, tolerance){\r\n	if(!mouseDown){\r\n		associatedPoint = null;\r\n		return;\r\n	}\r\n	dragAssocPoint(associatedPoint);\r\n	\r\n	for(var i = 0;i < points.length;i++){\r\n		if(getDist(mouse, points[i]) < tolerance){\r\n			associatedPoint = points[i];\r\n			break;\r\n		}\r\n	}\r\n}\r\nfunction dragAssocPoint(associatedPoint){\r\n	if(associatedPoint == null){\r\n		return;\r\n	}\r\n	associatedPoint.x = mouse.x;\r\n	associatedPoint.y = mouse.y;\r\n}\r\n\r\nvar mouse = new point(10, 10);\r\nvar mouseDown = false;\r\ncanvas.addEventListener(\'mousemove\', function(e){\r\n	mouse.x = e.clientX - canvas.width/2;\r\n	mouse.y = (e.clientY - canvas.height/2);\r\n});\r\ncanvas.addEventListener(\'mousedown\', function(e){\r\n	mouseDown = true;\r\n});\r\ncanvas.addEventListener(\'mouseup\', function(e){\r\n	mouseDown = false;\r\n});\r\ncanvas.addEventListener(\'click\', function(e){\r\n	if(associatedPoint != null){\r\n		return;\r\n	}\r\n	bezieForm.push(new point(mouse.x, mouse.y));\r\n});\r\n\r\n\r\nfunction clear(){\r\n  ctx.clearRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);\r\n}\r\n\r\nfunction getDir(pointA, pointB){\r\n	//return Math.atan(-(pointB.y - pointA.y) / (pointB.x - pointA.x));\r\n	return -Math.atan2(pointB.x - pointA.x, pointB.y - pointA.y) + Math.PI/2;\r\n}\r\n\r\nfunction getDist(pointA, pointB){\r\n	return Math.sqrt((pointA.x - pointB.x) * (pointA.x - pointB.x) + (pointA.y - pointB.y) * (pointA.y - pointB.y));\r\n}\r\n\r\nfunction rand(min, max){\r\n	return Math.floor(Math.random() * max) + min;\r\n}\r\n\r\nfunction point(x, y){\r\n	this.x = x;\r\n	this.y = y;\r\n}\r\n\r\nfunction drawLine(pointA, pointB, size, color){\r\n	x1 = pointA.x;\r\n	y1 = pointA.y;\r\n	x2 = pointB.x;\r\n	y2 = pointB.y;\r\n	\r\n	y2 = y2;\r\n	y1 = y1;\r\n\r\n	ctx.strokeStyle = color;\r\n	ctx.lineWidth = size;\r\n	ctx.beginPath();\r\n	ctx.moveTo(x1, y1);\r\n	ctx.lineTo(x2, y2);\r\n	ctx.stroke();\r\n	ctx.closePath();\r\n}', '2018-01-23 22:27:23', 1);

-- --------------------------------------------------------

--
-- Table structure for table `users`
--

-- CREATE TABLE `users` (
--   `id` int(11) NOT NULL,
--   `name` varchar(50) NOT NULL,
--   `email` varchar(50) NOT NULL,
--   `pass_hash` varchar(256) NOT NULL
-- ) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `users`
--

INSERT INTO `users` (`id`, `name`, `email`, `pass_hash`) VALUES
(1, 'ichko', 'test@test.com', '9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08');

--
-- Indexes for dumped tables
--

--
-- Indexes for table `snippets`
--
-- ALTER TABLE `snippets`
--   ADD PRIMARY KEY (`id`);

--
-- Indexes for table `users`
--
-- ALTER TABLE `users`
--   ADD PRIMARY KEY (`id`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `snippets`
--
ALTER TABLE `snippets`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=11;

--
-- AUTO_INCREMENT for table `users`
--
ALTER TABLE `users`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
